<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gincana - SIPAT 2025 Energia</title>
  <style>
    :root {
      --background: 204 12.1951% 91.9608%;
      --foreground: 0 0% 20%;
      --card: 0 0% 100%;
      --primary: 13.2143 73.0435% 54.902%;
      --primary-foreground: 0 0% 100%;
      --secondary: 220 14.2857% 95.8824%;
      --muted: 210 20% 98.0392%;
      --muted-foreground: 220 8.9362% 46.0784%;
      --accent: 207.6923 46.4286% 89.0196%;
      --border: 210 9.375% 87.451%;
      --radius: 0.75rem;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
      background: radial-gradient(
          circle at 20% 20%,
          rgba(255, 107, 0, 0.1) 0%,
          transparent 40%
        ),
        radial-gradient(
          circle at 80% 80%,
          rgba(255, 153, 0, 0.08) 0%,
          transparent 40%
        ),
        linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.02) 0%,
          rgba(255, 255, 255, 0.05) 50%,
          rgba(255, 255, 255, 0.02) 100%
        ),
        repeating-linear-gradient(
          45deg,
          transparent,
          transparent 100px,
          rgba(255, 255, 255, 0.01) 100px,
          rgba(255, 255, 255, 0.01) 200px
        ),
        hsl(var(--background));
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow-x: hidden;
    }

    body::before {
      content: "";
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: radial-gradient(
          circle at 30% 70%,
          rgba(255, 107, 0, 0.03) 0%,
          transparent 50%
        ),
        radial-gradient(
          circle at 70% 30%,
          rgba(255, 153, 0, 0.02) 0%,
          transparent 50%
        );
      pointer-events: none;
      z-index: -1;
      animation: backgroundShift 20s ease-in-out infinite;
    }

    @keyframes backgroundShift {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.1); }
    }

    .top-nav {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      padding: 15px;
      display: flex;
      justify-content: center;
      gap: 40px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 
        0 1px 0 rgba(255, 255, 255, 0.1) inset,
        0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .nav-item {
      color: hsl(var(--primary));
      font-weight: 600;
      font-size: 18px;
      text-decoration: none;
      padding: 10px 20px;
      border-radius: var(--radius);
      transition: all 0.3s ease;
      position: relative;
    }

    .nav-item:hover {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .nav-item.active {
      background: rgba(255, 255, 255, 0.2);
      color: hsl(var(--primary));
      box-shadow: 
        0 1px 0 rgba(255, 255, 255, 0.2) inset,
        0 2px 10px rgba(0, 0, 0, 0.15);
    }

    .main-content {
      flex: 1;
      padding: 40px 20px;
      width: 100%;
    }

    .page-title {
      text-align: center;
      font-size: 3rem;
      color: hsl(var(--foreground));
      margin-bottom: 40px;
      font-weight: 600;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 30px;
      max-width: 1200px;
      margin: 0 auto;
    }

    .game-card {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(40px) saturate(200%) brightness(110%);
      -webkit-backdrop-filter: blur(40px) saturate(200%) brightness(110%);
      border-radius: calc(var(--radius) * 2);
      border: 1px solid rgba(255, 255, 255, 0.2);
      overflow: hidden;
      transition: all 0.3s ease;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.08),
        0 1px 0 rgba(255, 255, 255, 0.3) inset;
      display: flex;
      flex-direction: column;
    }

    .game-card:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-4px);
      box-shadow: 
        0 16px 48px rgba(0, 0, 0, 0.12),
        0 1px 0 rgba(255, 255, 255, 0.4) inset;
      border-color: rgba(255, 255, 255, 0.3);
    }

    .game-header {
      background: linear-gradient(135deg, hsl(var(--primary)) 0%, rgba(255, 153, 0, 0.9) 100%);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: white;
      padding: 20px;
      text-align: center;
      font-size: 24px;
      font-weight: 600;
      box-shadow: 
        0 1px 0 rgba(255, 255, 255, 0.2) inset,
        0 2px 8px rgba(255, 107, 0, 0.3);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    }

    .game-content {
      padding: 30px 20px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      min-height: 200px;
      position: relative;
      flex: 1;
    }

    .game-image {
      width: 120px;
      height: 120px;
      background: linear-gradient(135deg, hsl(var(--muted)) 0%, hsl(var(--accent)) 100%);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: var(--radius);
      margin-bottom: 20px;
      background-size: cover;
      background-position: center;
      opacity: 0.8;
    }

    .game-btn {
      padding: 15px 30px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: hsl(var(--foreground));
      font-weight: 600;
      font-size: 16px;
      border-radius: var(--radius);
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.1),
        0 1px 0 rgba(255, 255, 255, 0.2) inset;
    }

    .game-btn:hover {
      background: linear-gradient(135deg, hsl(var(--primary)) 0%, rgba(255, 153, 0, 0.9) 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: 
        0 6px 16px rgba(255, 107, 0, 0.4),
        0 1px 0 rgba(255, 255, 255, 0.3) inset;
      border-color: rgba(255, 107, 0, 0.6);
    }

    .back-btn {
      position: fixed;
      top: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: hsl(var(--foreground));
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 10px 15px;
      border-radius: var(--radius);
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      z-index: 100;
      box-shadow: 
        0 4px 12px rgba(0, 0, 0, 0.1),
        0 1px 0 rgba(255, 255, 255, 0.2) inset;
    }

    .back-btn:hover {
      background: linear-gradient(135deg, hsl(var(--primary)) 0%, rgba(255, 153, 0, 0.9) 100%);
      color: white;
      transform: translateY(-2px);
      box-shadow: 
        0 6px 16px rgba(255, 107, 0, 0.4),
        0 1px 0 rgba(255, 255, 255, 0.3) inset;
      border-color: rgba(255, 107, 0, 0.6);
    }

    @media (max-width: 1024px) {
      .games-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
      }
    }

    @media (max-width: 768px) {
      .top-nav {
        gap: 15px;
        padding: 12px 8px;
        flex-wrap: wrap;
      }

      .nav-item {
        font-size: 15px;
        padding: 8px 12px;
      }

      .main-content {
        padding: 30px 15px;
      }

      .page-title {
        font-size: 2.5rem;
        margin-bottom: 30px;
      }

      .games-grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }

      .game-content {
        min-height: 180px;
        padding: 25px 15px;
      }

      .game-image {
        width: 100px;
        height: 100px;
      }
    }

    @media (max-width: 480px) {
      .top-nav {
        gap: 8px;
        padding: 10px 5px;
        flex-direction: column;
        align-items: center;
      }

      .nav-item {
        font-size: 14px;
        padding: 8px 16px;
        width: 100%;
        max-width: 200px;
        text-align: center;
      }

      .main-content {
        padding: 20px 10px;
      }

      .page-title {
        font-size: 2rem;
        margin-bottom: 20px;
      }

      .game-header {
        font-size: 20px;
        padding: 15px;
      }

      .game-content {
        min-height: 150px;
        padding: 20px 10px;
      }

      .game-image {
        width: 80px;
        height: 80px;
      }

      .game-btn {
        padding: 12px 20px;
        font-size: 14px;
      }
    }
  </style>
</head>
<body>
  <a href="../" class="back-btn">← Voltar</a>

  <nav class="top-nav">
    <a href="../" class="nav-item">PRINCIPAL</a>
    <a href="#" class="nav-item active">GINCANA GAMES</a>
    <a href="../desenho/" class="nav-item">CONCURSO DESENHO</a>
  </nav>

  <div class="main-content">
    <h1 class="page-title">GINCANA GAMES</h1>
    
    <div class="games-grid">
      <div class="game-card">
        <div class="game-header">CAÇA PALAVRAS</div>
        <div class="game-content">
          <div class="game-image"></div>
          <a href="../cacapalavra/" class="game-btn">JOGAR</a>
        </div>
      </div>

      <div class="game-card">
        <div class="game-header">FORCA</div>
        <div class="game-content">
          <div class="game-image"></div>
          <a href="../forca/" class="game-btn">JOGAR</a>
        </div>
      </div>

      <div class="game-card">
        <div class="game-header">CRUZADINHA</div>
        <div class="game-content">
          <div class="game-image"></div>
          <a href="../cruzadinha/" class="game-btn">JOGAR</a>
        </div>
      </div>

      <div class="game-card">
        <div class="game-header">RANKING</div>
        <div class="game-content">
          <div class="game-image"></div>
          <a href="../ranking/" class="game-btn">VER RANKING</a>
        </div>
      </div>
    </div>
  </div>

  <canvas id="liquidGlass" style="position: fixed; top: 0; left: 0; pointer-events: none; z-index: 0; opacity: 0.08;"></canvas>

  <script id="fragmentShader" type="x-shader/x-fragment">
    precision mediump float;
    uniform float u_dpr;
    uniform sampler2D u_background;
    uniform vec2 u_resolution;
    uniform vec2 u_mouse;
    uniform vec2 u_size;
    varying vec2 v_uv;

    float cssPxUV() {
      return u_dpr / min(u_resolution.x, u_resolution.y);
    }

    float roundedBox(vec2 uv, vec2 center, vec2 size, float radius) {
      vec2 q = abs(uv - center) - size + radius;
      return length(max(q, 0.0)) - radius;
    }

    vec3 blurBackground(vec2 uv, vec2 resolution) {
      vec3 result = vec3(0.0);
      float total = 0.0;
      float radius = 3.0;
      
      for(int x = -3; x <= 3; x++) {
        for(int y = -3; y <= 3; y++) {
          vec2 offset = vec2(float(x), float(y)) * 2.0 / resolution;
          float weight = exp(-(float(x*x + y*y)) / (2.0 * radius));
          result += texture2D(u_background, uv + offset).rgb * weight;
          total += weight;
        }
      }
      return result / total;
    }

    float roundedBoxSDF(vec2 p, vec2 b, float r) {
      vec2 d = abs(p) - b + vec2(r);
      return length(max(d, 0.0)) - r;
    }

    vec2 getNormal(vec2 uv, vec2 center, vec2 size, float radius) {
      vec2 eps = vec2(1.0) / u_resolution * 2.0;
      vec2 p = uv - center;
      
      float dx = (roundedBoxSDF(p + vec2(eps.x, 0.0), size, radius) - 
                  roundedBoxSDF(p - vec2(eps.x, 0.0), size, radius)) * 0.5;
      float dy = (roundedBoxSDF(p + vec2(0.0, eps.y), size, radius) - 
                  roundedBoxSDF(p - vec2(0.0, eps.y), size, radius)) * 0.5;
      
      vec2 gradient = vec2(dx, dy);
      
      if(length(gradient) < 0.001) {
        return vec2(0.0);
      }
      
      return normalize(gradient);
    }

    void main() {
      vec2 pixelUV = (v_uv * u_resolution) / u_dpr;
      vec2 center = u_mouse;
      vec2 size = u_size * 0.5;
      vec2 local = (pixelUV - center) / size;
      local.y *= u_resolution.x / u_resolution.y;
      
      float radius = 20.0;
      float dist = roundedBox(pixelUV, center, size, radius);
      
      if(dist > 1.0) {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        return;
      }
      
      float r = clamp(length(local * 1.0), 0.0, 1.0);
      float curvature = pow(r, 1.0);
      
      vec2 domeNormal = normalize(local) * curvature;
      float eta = 1.0 / 1.5;
      vec2 incident = -domeNormal;
      vec2 refractVec = refract(incident, domeNormal, eta);
      vec2 curvedRefractUV = v_uv + refractVec * 0.03;
      
      float contourFalloff = exp(-abs(dist) * 0.4);
      vec2 normal = getNormal(pixelUV, center, size, radius);
      vec2 domeNormalContour = normal * pow(contourFalloff, 1.5);
      vec2 refractVecContour = refract(vec2(0.0), domeNormalContour, eta);
      vec2 uvContour = v_uv + refractVecContour * 0.35 * contourFalloff;
      
      float edgeWeight = smoothstep(0.0, 1.0, abs(dist));
      float radialWeight = smoothstep(0.5, 1.0, r);
      float combinedWeight = clamp((edgeWeight * 1.0) + (-radialWeight * 0.5), 0.0, 1.0);
      
      vec2 refractUV = mix(curvedRefractUV, uvContour, combinedWeight);
      
      vec3 base = vec3(0.1, 0.1, 0.15);
      
      float edgeFalloff = smoothstep(0.01, 0.0, dist);
      float verticalBand = 1.0 - smoothstep(-1.5, -0.2, local.y);
      float topShadow = edgeFalloff * verticalBand;
      
      vec3 shadowColor = vec3(0.0);
      base = mix(base, shadowColor, topShadow * 0.05);
      
      float edge = 1.0 - smoothstep(0.0, 0.05, dist * -1.0);
      vec3 glow = vec3(0.2, 0.15, 0.1);
      vec3 color = mix(base, glow, edge * 0.1);
      
      float alpha = 0.05;
      gl_FragColor = vec4(color, alpha);
    }
  </script>

  <script id="vertexShader" type="x-shader/x-vertex">
    attribute vec2 a_position;
    varying vec2 v_uv;

    void main() {
      v_uv = vec2(a_position.x, -a_position.y) * 0.5 + 0.5;
      gl_Position = vec4(a_position, 0.0, 1.0);
    }
  </script>

  <script>
    const glCanvas = document.getElementById("liquidGlass");
    const glContext = glCanvas.getContext("webgl", { antialias: true }) || glCanvas.getContext("experimental-webgl", { antialias: true });
    
    if (glContext) {
      function resizeGL() {
        const dpr = window.devicePixelRatio || 1;
        glCanvas.width = window.innerWidth * dpr;
        glCanvas.height = window.innerHeight * dpr;
        glCanvas.style.width = window.innerWidth + 'px';
        glCanvas.style.height = window.innerHeight + 'px';
        glContext.viewport(0, 0, glCanvas.width, glCanvas.height);
      }

      window.addEventListener("resize", resizeGL);
      resizeGL();

      const vertexShaderSrc = document.getElementById("vertexShader").textContent;
      const fragmentShaderSrc = document.getElementById("fragmentShader").textContent;

      function compileShader(type, source) {
        const shader = glContext.createShader(type);
        glContext.shaderSource(shader, source);
        glContext.compileShader(shader);
        if (!glContext.getShaderParameter(shader, glContext.COMPILE_STATUS)) {
          console.error("Shader compile error:", glContext.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      const vertexShader = compileShader(glContext.VERTEX_SHADER, vertexShaderSrc);
      const fragmentShader = compileShader(glContext.FRAGMENT_SHADER, fragmentShaderSrc);

      if (vertexShader && fragmentShader) {
        const program = glContext.createProgram();
        glContext.attachShader(program, vertexShader);
        glContext.attachShader(program, fragmentShader);
        glContext.linkProgram(program);

        if (glContext.getProgramParameter(program, glContext.LINK_STATUS)) {
          glContext.useProgram(program);

          const positionBuffer = glContext.createBuffer();
          glContext.bindBuffer(glContext.ARRAY_BUFFER, positionBuffer);
          glContext.bufferData(glContext.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1
          ]), glContext.STATIC_DRAW);

          const positionLocation = glContext.getAttribLocation(program, "a_position");
          glContext.enableVertexAttribArray(positionLocation);
          glContext.vertexAttribPointer(positionLocation, 2, glContext.FLOAT, false, 0, 0);

          const u_resolution = glContext.getUniformLocation(program, "u_resolution");
          const u_mouse = glContext.getUniformLocation(program, "u_mouse");
          const u_size = glContext.getUniformLocation(program, "u_size");
          const u_dpr = glContext.getUniformLocation(program, "u_dpr");

          let targetMouse = [window.innerWidth / 2, window.innerHeight / 2];
          let currentMouse = [...targetMouse];
          let targetSize = [200, 100];
          let currentSize = [...targetSize];

          glCanvas.addEventListener("mousemove", e => {
            targetMouse = [e.clientX, e.clientY];
          });

          let lastTime = performance.now();

          function drawGL(now) {
            const delta = (now - lastTime) / 1000;
            lastTime = now;
            const speed = 3.0;

            currentMouse[0] += (targetMouse[0] - currentMouse[0]) * speed * delta;
            currentMouse[1] += (targetMouse[1] - currentMouse[1]) * speed * delta;
            currentSize[0] += (targetSize[0] - currentSize[0]) * speed * delta;
            currentSize[1] += (targetSize[1] - currentSize[1]) * speed * delta;

            resizeGL();
            glContext.clear(glContext.COLOR_BUFFER_BIT);
            glContext.uniform2f(u_resolution, glCanvas.width, glCanvas.height);
            glContext.uniform2f(u_mouse, currentMouse[0], currentMouse[1]);
            glContext.uniform2f(u_size, currentSize[0], currentSize[1]);
            glContext.uniform1f(u_dpr, window.devicePixelRatio || 1);

            glContext.drawArrays(glContext.TRIANGLES, 0, 6);
            requestAnimationFrame(drawGL);
          }

          requestAnimationFrame(drawGL);
        }
      }
    }
  </script>
</body>
</html>
